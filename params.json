{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Copper","google":"","body":"Copper\r\n======\r\n\r\nCopper is a Javascript implementation of Composite Oriented Programming.\r\nThe idea is that instead of declaring types (classes) and using\r\ninheritance to extend those, you assemble or compose data types\r\nfrom other objects or types.\r\n\r\nIn traditional class based languages such as Java you would do\r\nsomething like this:\r\n```java\r\npublic class Person {\r\n    private String name;\r\n    public Person(String name) {\r\n        this.name = name;\r\n    }\r\n    public void sayName() {\r\n        return \"My name is \" + name;\r\n    }\r\n}\r\n\r\npublic class Employee extends Person {\r\n    private int employeeNumber;\r\n    public Employee(String name, int employeeNumber) {\r\n        super(name);\r\n        this.employeeNmber = employeeNumber;\r\n    }\r\n    public String sayNumber() {\r\n        return \"My number is \" + employeeNumber;\r\n    }\r\n}\r\n// Usage\r\nPerson p = new Person(\"John\");\r\nSystem.out.println(p.sayName()); // \"My name is John\"\r\nEmployee emp = new Person(\"George\", 123);\r\nSystem.out.println(emp.sayName()); // My name is George\r\nSystem.out.println(emp.sayNumber()); // My number is 123\r\n```\r\n\r\nWhereas in a Composite Oriented Programming system, such as Copper\r\nyou would do this:\r\n\r\n```javascript\r\nvar personBehaviour = {\r\n    sayName: function() {\r\n        return 'My name is ' + this.name\r\n    }\r\n}\r\nvar employeeBehaviour = {\r\n    sayNumber: function() {\r\n        return 'My number is ' + this.employeeNumber\r\n    }\r\n}\r\ncopper.compose({\r\n      name: 'Person'\r\n    , mixins: [\r\n        personBehaviour\r\n    ]\r\n    , create: function(name) {\r\n        this.name = name\r\n    }\r\n})\r\ncopper.compose({\r\n      name: 'Employee'\r\n    , mixins: [\r\n          personBehaviour\r\n        , employeeBehaviour\r\n    ]\r\n    , create: function(name, employeeNumber) {\r\n        this.name = name\r\n        this.employeeNumber = employeeNumber\r\n    }\r\n})\r\nvar person = copper.create('Person', 'John')\r\nperson.sayName()                // My name is John\r\nvar emp = copper.create('Employee', 'George', 123)\r\nconsole.log(emp.sayName())      // My name is George\r\nconsole.log(emp.sayNumber())    // My number is 123\r\n```\r\n\r\nInstead of defining a type (a class), you define the behaviour and then\r\ncompose your objects using these behaviours.\r\n\r\nBut wait! There is more!\r\n------------------------\r\n\r\nIn addition to mixins, you can add traditional Aspect Oriented Programming\r\nadvices to your composed objects. Lets work the employee a little more:\r\n\r\n```javascript\r\ncopper.compose({\r\n      name: 'Employee'\r\n    , mixins: [\r\n          personBehaviour\r\n        , employeeBehaviour\r\n    ]\r\n    , after: {\r\n        'sayName': function(ret) {\r\n            return ret + ' and my number is ' + this.employeeNumber\r\n        }\r\n    }\r\n    , create: function(name, employeeNumber) {\r\n        this.name = name\r\n        this.employeeNumber = employeeNumber\r\n    }\r\n})\r\nvar emp = copper.create('Employee', 'George', 123)\r\nconsole.log(emp.sayName())      // My name is George and my number is 123\r\n```\r\n\r\nHere's what you can do with copper:\r\n```javascript\r\n// Create AND register\r\nvar foo = copper.compose({\r\n      name: 'optional name'\r\n    , mixins: [all your mixin objects]\r\n    , before: {method: function}\r\n    , after: {method: function}\r\n    , around: {\r\n        method: function(param1, param2, yield) {\r\n            // Do something\r\n            yield(param1, param2)\r\n            // Do some more\r\n        }\r\n    }\r\n    , create: function() {\r\n        // Optional constructor\r\n    }\r\n})\r\n// Composition without a name means that\r\n// the composed object is not registered\r\n// as an assembly\r\nvar composition = {\r\n    mixins: [{\r\n        hello: function() {\r\n            return 'Hello World'\r\n        }\r\n    }]\r\n}\r\n// Just create using #compose\r\nvar bar = copper.compose(composition) // definition MINUS the name\r\n// or you can use #create\r\nbar = copper.create(composition)\r\n\r\n// Get an instance of a registered assembly\r\nvar baz = copper.create('name.of.registered.assembly')\r\n\r\n// Mixin your objects on the fly\r\ncopper.mixin(baz, mixin1, mixin2)\r\n\r\n// Add advices on the fly\r\ncopper.before(adviceFunction, baz, 'methodName')\r\ncopper.after(adviceFunction, baz, 'methodName')\r\ncopper.around(adviceFunction, baz, 'methodName')\r\n\r\n```\r\n\r\nHave fun!\r\n\r\n\r\n","tagline":"Copper is a Javascript implementation of Composite Oriented Programming."}